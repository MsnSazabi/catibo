//! Catibo provides support for the CTB family of formats, used by popular
//! low-end resin 3D printers.
//!
//! # Common elements
//!
//! The family of file formats handled here are related by a common file header
//! layout and overall structure.
//!
//! - Multi-byte values, such as `u32` and `f32`, are encoded in little-endian,
//! and are *not* aligned in any particular way.
//!
//! - Many parameters in the file are represented in floating point,
//! specifically single-precision IEEE754 floating point.
//!
//! - References within the file are stored as a byte offset from the start of
//! the file, encoded as a `u32`, giving a maximum practical file size of just
//! under 4GiB. Some sections of the file are referenced using both an offset
//! and length, allowing them to change in size.
//!
//! - All formats contain stretches of unused bytes that appear to be reserved
//! for future expansion. Files generated by the proprietary C++ software fill
//! these sections with snapshots of arbitrary sections of stack memory; this
//! implementation ignores them on input and zeroes them on output.
//!
//! - Each file begins with a *magic number*, a 4-byte value identifying the
//! variant of the file format, and a *version*, a `u32` that could distinguish
//! revisions of the format, but in practice is constant.
//!
//! - The first chunk of the file is a *file header*, a fixed-size record that
//! describes the layout of the rest of the file, along with some of the machine
//! settings. Nothing else in the file is at a fixed location -- every location
//! is derived from this header.
//!
//! - Portions of the machine settings are in separate blocks, referenced from
//! the file header. The distribution of settings seems a little random, and may
//! reflect the order of development.
//!
//! - There are two *preview images* referenced from the file header, used to
//! display a thumbnail of the model in the file browser and confirmation screen
//! on the printer. These images are encoded in a simple embedded-friendly
//! format with limited color depth.
//!
//! - There is a *layer table*, containing fixed size records, one per
//! layer/slice of the model. Each record gives some information about the
//! slice, and contains a further reference to where the encoded slice data is
//! stored in the file.
//!
//! - Encoded layers are represented using simple RLE compression schemes (two
//! have been observed in the wild), with optional encryption.
//!
//! # Different formats
//!
//! This section gives a high-level, informal description of differences between
//! the formats in the family.
//!
//! ## Planar Level-Set Format
//!
//! Slices are encoded as bitmaps, recording whether each voxel is "inside"
//! (solid) or "outside" (empty) the model for each slice along the Z axis. When
//! antialiasing is enabled, multiple complete sets of bitmaps appear, each
//! using a more permissive "in" test than the last. This winds up representing
//! a collection of shells or level-sets of the model, starting at its solid
//! surface and moving out along a distance/occupancy field.
//!
//! This representation has the advantage that an antialiased file can be
//! converted to a bilevel file by just ignoring all level sets after the first.
//! (I suspect that it was added to the format after release, and is a
//! backwards-compatible way of introducing antialiasing.)
//!
//! The main disadvantage is size: X-level antialiasing requires X full copies
//! of the model data. (Not `log2 X`.)
//!
//! - Typical file extension: `cbddlp`
//! - Observed in the wild on: Elegoo Mars, some Anycubic Photon.
//! - Preview format: RGB 565 using RLE12 encoding.
//! - Slice format: Bilevel using RLE1 encoding.
//! - Antialiasing: optional, encoded using level sets.
//!
//! ## Multilevel Format
//!
//! Slices are encoded as multilevel images ("grayscale", except the gray level
//! represents solidity / exposure), one per slice along the Z axis. When
//! antialiasing is disabled, slices are thresholded to only contain their
//! highest and lowest values.
//!
//! This representation is strictly more space-efficient for antialiased images
//! than the Planar Level-Set format. It is *probably* also more compact for
//! non-antialiased images, because the run-length encoding has changed, and can
//! now encode runs of more than 127 pixels compactly. Because most of the print
//! volume is usually empty space, runs tend to dominate.
//!
//! This file encoding is the first one observed in the wild to be using
//! encryption.
//!
//! - Typical file extension: `ctb`
//! - Observed in the wild on: Creality LD-002R
//! - Preview format: RGB 565 using RLE12 encoding.
//! - Slice format: 7BPP using RLE7 encoding.
//! - Encryption: optional.

#![warn(
    bare_trait_objects,
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unreachable_pub,
    unsafe_code,
    unused_qualifications
)]

pub mod crypto;
pub mod input;
pub mod output;
pub mod rle;

use byteorder::LittleEndian;
use num_derive::{FromPrimitive, ToPrimitive};
use zerocopy::{AsBytes, FromBytes, Unaligned};

/// Enumeration of known magic number values. Also punned as a way of indicating
/// file formats.
#[derive(Copy, Clone, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
#[repr(u32)]
pub enum Magic {
    /// Indicates the planar level-set format (CBDDLP).
    PlanarLevelSet = 0x12fd_0019,
    /// Indicates the multilevel format (CTB).
    Multilevel = 0x12fd_0086,
    // Observed in the wild but not yet fully implemented:
    PlanarLevelSet2 = 0x9fda83ae, // TODO wrong name
}

impl Magic {
    /// Checks whether a given version number is recognized for files with this
    /// magic number.
    pub fn is_version_ok(self, version: u32) -> bool {
        // Currently, every file observed in the wild uses version 2.
        version == 2
    }

    /// Checks whether files with this magic number are expected to use
    /// level-based AA representation, where slices are multiplied.
    pub fn uses_aa_levels(self) -> bool {
        match self {
            Self::Multilevel => false,
            Self::PlanarLevelSet | Self::PlanarLevelSet2 => true,
        }
    }

    pub fn header_style(self) -> HeaderStyle {
        match self {
            Magic::PlanarLevelSet2 => HeaderStyle::Omni,
            _ => HeaderStyle::Split,
        }
    }
}

/// Distinguishes styles of header when the magic is asked.
#[derive(Copy, Clone, Debug)]
pub enum HeaderStyle {
    Split,
    Omni,
}

/// Shorthand for little-endian `u32`s.
pub type U32LE = zerocopy::byteorder::U32<LittleEndian>;
/// Shorthand for little-endian `u16`s.
pub type U16LE = zerocopy::byteorder::U16<LittleEndian>;

/// A little-endian `f32`, not necessarily aligned.
#[derive(Copy, Clone, Default, AsBytes, FromBytes, Unaligned)]
#[repr(transparent)]
pub struct F32LE(U32LE);

impl F32LE {
    /// Encodes an `f32` in little-endian.
    ///
    /// Note that chances are very good this is a no-op, since the computer
    /// you're using is likely to be natively little-endian.
    pub fn new(val: f32) -> Self {
        F32LE(U32LE::new(val.to_bits()))
    }

    /// Decodes the `f32` from little-endian.
    pub fn get(self) -> f32 {
        f32::from_bits(self.0.get())
    }
}

impl core::fmt::Debug for F32LE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        self.get().fmt(f)
    }
}

/// Common file header layout. This comes at the start of the file and tells us
/// what to look for next.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct MagicHeader {
    /// Magic number that determines the file encoding, etc. Values we currently
    /// understand are listed in the `Magic` enum.
    pub magic: U32LE,
    /// File format version number. In practice, always 2.
    pub version: U32LE,
}

/// Split file header layout.
///
/// This header record is split over three physical records: this one,
/// `ExtConfig`, and `ExtConfig2`. It preferences the other two by offset and
/// size. (This appears to be for historical reasons.)
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct SplitHeader {
    /// Printer output volume in millimeters along X, Y, Z.
    pub printer_out_mm: [F32LE; 3],

    /// Unknown sequence of 8 bytes, always contains zeros in the wild.
    pub _unknown_14: [u8; 8],
    /// Overall height of model in mm.
    pub overall_height_mm: F32LE,

    /// File-wide layer height setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual layer height
    /// is given for each layer in the layer table, and can vary.
    pub layer_height_mm: F32LE,

    /// File-wide normal layer exposure setting. This reflects the setting used
    /// in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub exposure_s: F32LE,

    /// File-wide "bottom" layer exposure setting. This reflects the setting
    /// used in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub bot_exposure_s: F32LE,

    /// File-wide off-time setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual off-time is
    /// given for each layer in the layer table, and can vary.
    pub light_off_time_s: F32LE,

    /// Number of layers considered to be "bottom". This reflects the setting
    /// used in the slicer and is not used during printing.
    pub bot_layer_count: U32LE,

    /// Printer resolution along X, Y axes.
    pub resolution: [U32LE; 2],

    /// File offset of the large preview image's `ImageHeader`.
    pub large_preview_offset: U32LE,

    /// File offset of the first `LayerHeader`.
    pub layer_table_offset: U32LE,
    /// Number of `LayerHeader`s in the layer table.
    pub layer_table_count: U32LE,

    /// File offset of the small preview image's `ImageHeader`.
    pub small_preview_offset: U32LE,

    /// Estimated print time, in seconds.
    pub print_time_s: U32LE,

    /// Normal (0) or `LCD_mirror` (1) transform required for printer. This
    /// doesn't appear to actually control any printer behavior.
    pub mirror: U32LE,

    /// File offset of the `ExtConfig` record.
    pub ext_config_offset: U32LE,
    /// Length of the `ExtConfig` record in bytes. In practice, this is always
    /// `0x3C`, and our `ExtConfig` struct is sized to reflect this -- but it
    /// appears to be padded for expansion and the final bytes are unused.
    pub ext_config_size: U32LE,

    /// Level set count. This records the number of copies of each layer that
    /// are present. For 1bpp representations, this is equivalent to the
    /// antialiasing level (because those formats implement antialiasing by
    /// repetition). For 7bpp representations, this appears to be ignored,
    /// and should be set to `1` for consistency.
    pub level_set_count: U32LE,

    /// UV LED PWM level for normal layers. While stored in a 16-bit field this
    /// appears to be an 8-bit value. Larger numbers mean higher duty cycle.
    pub pwm_level: U16LE,
    /// UV LED PWM level for bottom layers.
    pub bot_pwm_level: U16LE,

    /// Encryption key. Zero means unencrypted. File formats that don't normally
    /// use encryption should zero this.
    pub encryption_key: U32LE,

    /// File offset of the `ExtConfig2` record.
    pub ext_config2_offset: U32LE,
    /// Length of the `ExtConfig2` record, in bytes. In practice, this is always
    /// `0x4C`, and our `ExtConfig2` struct is sized to reflect this -- but it
    /// appears to be padded for expansion and the final bytes are unused.
    pub ext_config2_size: U32LE,
}

/// Configuration extension record. This includes some print settings that are
/// not part of the file header.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ExtConfig {
    /// Bed lift distance during bottom layers, in millimeters.
    pub bot_lift_dist_mm: F32LE,
    /// Bed lift speed during bottom layers, in millimeters per minute.
    pub bot_lift_speed_mmpm: F32LE,
    /// Bed lift distance during normal layers, in millimeters.
    pub lift_dist_mm: F32LE,
    /// Bed lift speed during normal layers, in millimeters per minute.
    pub lift_speed_mmpm: F32LE,
    /// Retract speed, in millimeters per minute. This is the speed at which the
    /// bed re-approaches the screen after lifting.
    pub retract_speed_mmpm: F32LE,
    /// Estimated volume of resin required for print, in milliliters.
    pub print_volume_ml: F32LE,
    /// Estimated weight of resin required for print, in grams. This is derived
    /// from the volume estimate according to the configured resin density.
    pub print_mass_g: F32LE,
    /// Estimated cost of resin required for print, in user's local currency.
    /// (Currency unit does not appear to be stored in the file, and changing it
    /// does not affect the estimate.)
    pub print_price: F32LE,
    /// Bottom-layer light off-time, in seconds. This determines how long the
    /// light is off between bottom layers.
    pub bot_light_off_time_s: F32LE,
    /// Normal-layer light off-time, in seconds. This determines how long the
    /// light is off between non-bottom layers. Apparent duplicate of
    /// `SplitHeader::light_off_time_s`, always matches in the wild.
    pub light_off_time_s: F32LE,
    /// Number of layers considered to be "bottom." Apparent duplicate of
    /// `SplitHeader::bot_layer_count`, always matches in the wild.
    pub bot_layer_count: U32LE,

    /// 16 bytes apparently reserved for expansion
    pub _unknown_2c: [u8; 16],
}

/// Configuration extension record, volume two. This includes more print
/// settings that are not part of the file header.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ExtConfig2 {
    /// Unknown run of 28 bytes, always zero in practice.
    pub _unknown_0: [u8; 28],
    /// File offset of printer type name. This is the software's internal name
    /// for the printer type, *not* the user-assigned profile name.
    ///
    /// Note: while I've only observed ASCII in the machine type name, I
    /// strongly suspect it to be using UTF-8.
    pub machine_type_offset: U32LE,
    /// Number of bytes in printer type name.
    pub machine_type_len: U32LE,
    /// Controls the encryption parameters. This field is not completely
    /// understood. Zero for unencrypted files.
    ///
    /// The best understood encrypted files use `0xF` here.
    pub encryption_mode: U32LE,

    /// This mysterious number increments with some combination of time and
    /// slicing.
    pub mysterious_id: U32LE,

    /// User antialiasing setting.
    ///
    /// For 1bpp formats, this will match the `level_set_count` from the file
    /// header. For deeper formats (7bpp) this indicates whether thresholding
    /// was performed on the image data.
    pub antialias_level: U32LE,

    /// Software revision, stored as 0xmajor_minor_patch_00.
    pub software_version: U32LE,

    /// Observed as 0x200
    pub _unknown_34: U32LE,

    /// 20 bytes apparently reserved for future expansion.
    pub _unknown_38: [u8; 20],
}

/// Record used to describe the preview images.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ImageHeader {
    /// Size along X, Y, in pixels.
    pub size: [U32LE; 2],
    /// File offset of encoded image data.
    pub data_offset: U32LE,
    /// Length of encoded image data, in bytes.
    pub data_len: U32LE,

    /// Unknown 16-byte run. Always zero in proprietary output, probably
    /// reserved for expansion.
    pub _unknown_10: [u8; 16],
}

/// Record that describes a single layer/slice of the model.
///
/// Files contain a contiguous table of these, referenced from the file header.
/// These in turn reference each layer's data.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct LayerHeader {
    /// Position of the build platform for this layer, in millimeters.
    pub z: F32LE,
    /// Exposure time for this layer, in seconds.
    pub exposure_s: F32LE,
    /// Time the light should be kept off after this layer, in seconds.
    pub light_off_time_s: F32LE,
    /// File offset of this layer's encoded data.
    pub data_offset: U32LE,
    /// Length of this layer's encoded data, in bytes.
    pub data_len: U32LE,

    /// Unknown run of 16 bytes, always zeroed in practice.
    pub _unknown_14: [u8; 16],
}

/// A unified file header that combines the role of `SplitHeader`, `ExtConfig`,
/// and `ExtConfig2`, introduced circa 2020 in `phz` files.
///
/// This has field ordering and role that strongly suggests someone started with
/// the header files for the old header and moved lines around. The field names
/// match those in the other header records where their roles appear to be
/// equivalent.
///
/// The format of all referenced records (`ImageHeader`, `LayerHeader`) does not
/// appear to have changed.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct OmniHeader {
    pub layer_height_mm: F32LE,
    pub exposure_s: F32LE,
    pub bot_exposure_s: F32LE,
    pub bot_layer_count: U32LE,
    pub resolution: [U32LE; 2],
    pub large_preview_offset: U32LE,
    pub layer_table_offset: U32LE,
    pub layer_table_count: U32LE,
    pub small_preview_offset: U32LE,
    pub print_time_s: U32LE,
    pub mirror: U32LE,
    pub level_set_count: U32LE,
    pub pwm_level: U16LE,
    pub bot_pwm_level: U16LE,
    pub _zero_40: [u8; 8],
    pub overall_height_mm: F32LE,
    pub printer_out_mm: [F32LE; 3],
    pub encryption_key: U32LE,
    pub bot_light_off_time_s: F32LE,
    pub light_off_time_s: F32LE, // or vice versa, check
    pub bot_layer_count_again: U32LE,

    pub _zero_68: [u8; 4],

    // from top of ext_config
    pub bot_lift_dist_mm: F32LE,
    pub bot_lift_speed_mmpm: F32LE,
    pub lift_dist_mm: F32LE,
    pub lift_speed_mmpm: F32LE,
    pub retract_speed_mmpm: F32LE,
    pub print_volume_ml: F32LE,
    pub print_mass_g: F32LE,
    pub print_price: F32LE,

    pub _zero_8c: [u8; 4],

    // from ext_config2
    pub machine_type_offset: U32LE,
    pub machine_type_len: U32LE,

    // inserted
    pub _zero_98: [u8; 6 * 4],

    // more from ext_config2
    pub encryption_mode: U32LE,
    pub mysterious_id: U32LE,
    pub antialias_level: U32LE,
    pub software_version: U32LE,
    pub _zero_c0: [u8; 4 * 6],
}
